package optic_fusion1.mcantimalware;

import java.io.File;
import java.io.IOException;
import static java.util.Arrays.asList;
import joptsimple.OptionParser;
import joptsimple.OptionSet;
import static optic_fusion1.mcantimalware.Main.LOGGER;
import optic_fusion1.mcantimalware.runtimeprotect.PluginIndex;
import optic_fusion1.mcantimalware.utils.I18n;
import optic_fusion1.mcantimalware.utils.Utils;

//TODO: Make certain messages translatable
public class CommandLineParser {

  private OptionSet options;
  private File serverJar;
  private File scanFile;
  private File scanDirectory = new File("plugins");
  private String[] serverArguments = new String[]{};
  private PluginIndex pluginIndex;
  private final I18n I18n = new I18n();
  private boolean scanSingleFile = false;
  private String notifyType = "console";
  private boolean dumpClasses = false;
  private boolean banMaliciousAuthors = false;
  private boolean runServerJar = false;
  private boolean printNotInfectedMessage = true;
  private boolean runSecurityManager = true;
  private boolean useTransformers = true;
  private boolean scanDrives = false;
  private boolean disableAutoUpdate = false;
  private boolean singleScan = false;
  private boolean loadedCommandLineArguments = false;
  private boolean scanZippedFiles = true;
  private boolean logSecurityManager = true;
  private boolean spigotScanner = false;

  public void handleCommandLineArguments(String[] args) {
    if (loadedCommandLineArguments) {
      return;
    }
    OptionParser parser = new OptionParser() {
      {
        acceptsAll(asList("scanDirectory"), "Which folder to scan")
                .withRequiredArg()
                .ofType(String.class)
                .defaultsTo("plugins");
        acceptsAll(asList("scanFile"), "Scan a single file")
                .withRequiredArg()
                .ofType(String.class);
        acceptsAll(
                asList("printNotInfectedMessages"),
                "Should not infected messages be shown & logged")
                .withRequiredArg()
                .ofType(Boolean.class)
                .defaultsTo(true);
        acceptsAll(asList("help"), "Show the help");
        acceptsAll(asList("language"), "Changes the language of the program")
                .withRequiredArg()
                .ofType(String.class)
                .defaultsTo("en");
        acceptsAll(asList("notify"), "Allows you to set a notification method (Type: console, discord, popup)")
                .withRequiredArg()
                .ofType(String.class)
                .defaultsTo("console");
        acceptsAll(asList("serverJar"), "Path to the server jar that should be ran")
                .withRequiredArg()
                .ofType(String.class);
        acceptsAll(asList("serverArguments"), "Server arguments")
                .withRequiredArg()
                .ofType(String.class);
        acceptsAll(asList("banMalAuthors"), "Should we ban malicious authors and possible alts")
                .withRequiredArg()
                .ofType(Boolean.class)
                .defaultsTo(true);
        acceptsAll(asList("dumpClasses"), "Should classes in the classpath be saved")
                .withRequiredArg()
                .ofType(Boolean.class)
                .defaultsTo(false);
        acceptsAll(asList("runSecurityManager"), "Should the AntiMalware use a custom SecurityManager")
                .withRequiredArg()
                .ofType(Boolean.class)
                .defaultsTo(true);
        acceptsAll(asList("useTransformers"), "Should custom code be used? (Deals with a variety of methods malicious plugins use)")
                .withRequiredArg()
                .ofType(Boolean.class)
                .defaultsTo(true);
        acceptsAll(asList("scanDrives"), "Should all drives be scanned?")
                .withRequiredArg()
                .ofType(Boolean.class)
                .defaultsTo(false);
        acceptsAll(asList("disableAutoUpdate"), "Should auto updating be disabled")
                .withRequiredArg()
                .ofType(Boolean.class)
                .defaultsTo(false);
        acceptsAll(asList("singleScan"), "Should we only scan once")
                .withRequiredArg()
                .ofType(Boolean.class)
                .defaultsTo(false);
        acceptsAll(asList("scanZippedFiles"), "Should Zipped files be scanned? (Takes up space)")
                .withRequiredArg()
                .ofType(Boolean.class)
                .defaultsTo(true);
        acceptsAll(asList("logSM"), "Should the SecurityManager log messages")
                .withRequiredArg()
                .ofType(Boolean.class)
                .defaultsTo(true);
        acceptsAll(asList("spigotScanner"), "Should the latest resources be downloaded & scanned?")
                .withRequiredArg()
                .ofType(Boolean.class)
                .defaultsTo(false);
      }
    };
    try {
      options = parser.parse(args);
    } catch (joptsimple.OptionException ex) {
      LOGGER.exception(ex);
      System.exit(0);
    }
    if (options != null) {
      if (options.has("help")) {
        try {
          parser.printHelpOn(System.out);
        } catch (IOException ex) {
          LOGGER.exception(ex);
        }
        System.exit(0);
      }
      if (options.has("language")) {
        I18n.updateLocale((String) options.valueOf("language"));
      } else {
        I18n.updateLocale("en");
      }
      if (options.has("notify")) {
        notifyType = (String) options.valueOf("notify");
      }
      if (options.has("dumpClasses")) {
        dumpClasses = (boolean) options.valueOf("dumpClasses");
        int javaVersion = Utils.getJavaVersion();
        if (dumpClasses && javaVersion > 8) {
          LOGGER.info("Java version: {0} is being used, the ability to dump classes isn't supported", javaVersion);
          dumpClasses = false;
        }
      }
      if (options.has("serverJar")) {
        runServerJar = true;
        banMaliciousAuthors = true;
        pluginIndex = new PluginIndex();
        pluginIndex.indexPlugins(new File("plugins"));
        if (options.has("serverArguments")) {
          serverArguments = ((String) options.valueOf("serverArguments")).split(" ");
        }
        serverJar = new File((String) options.valueOf("serverJar"));
        if (!serverJar.exists()) {
          LOGGER.info(I18n.tl("file_doesn't_exist", serverJar));
          System.exit(0);
        }
      }
      if (options.has("scanFile")) {
        scanSingleFile = true;
        String value = (String) options.valueOf("scanFile");
        scanFile = new File(value.equals(".") ? "." : value);
        if (!scanFile.exists()) {
          LOGGER.info(I18n.tl("file_doesn't_exist", scanFile));
          System.exit(0);
        }
      }
      if (options.has("printNotInfectedMessages")) {
        printNotInfectedMessage = (boolean) options.valueOf("printNotInfectedMessages");
      }
      if (options.has("scanDirectory")) {
        scanDirectory = new File((String) options.valueOf("scanDirectory"));
        if (!scanDirectory.exists()) {
          LOGGER.info(I18n.tl("file_doesn't_exist", scanFile));
          System.exit(0);
        }
        if (pluginIndex != null) {
          pluginIndex.indexPlugins(scanDirectory);
        }
      }
      if (options.has("banMalAuthors")) {
        banMaliciousAuthors = (boolean) options.valueOf("banMalAuthors");
      }
      if (options.has("runSecurityManager")) {
        runSecurityManager = (boolean) options.valueOf("runSecurityManager");
      }
      if (options.has("useTransformers")) {
        useTransformers = (boolean) options.valueOf("useTransformers");
      }
      if (options.has("scanDrives")) {
        scanDrives = (boolean) options.valueOf("scanDrives");
      }
      if (options.has("disableAutoUpdate")) {
        disableAutoUpdate = (boolean) options.valueOf("disableAutoUpdate");
      }
      if (options.has("singleScan")) {
        singleScan = (boolean) options.valueOf("singleScan");
      }
      if (options.has("scanZippedFiles")) {
        scanZippedFiles = (boolean) options.valueOf("scanZippedFiles");
      }
      if (options.has("logSM")) {
        logSecurityManager = (boolean) options.valueOf("logSM");
      }
      if (options.has("spigotScanner")) {
        spigotScanner = (boolean) options.valueOf("spigotScanner");
      }
    }
    loadedCommandLineArguments = true;
  }

  public boolean shouldScanSingleFile() {
    return scanSingleFile;
  }

  public OptionSet getOptions() {
    return options;
  }

  public boolean shouldDumpClasses() {
    return dumpClasses;
  }

  public File getServerJar() {
    return serverJar;
  }

  public boolean shouldBanMaliciousAuthors() {
    return banMaliciousAuthors;
  }

  public boolean shouldRunServerJar() {
    return runServerJar;
  }

  public String[] getServerArguments() {
    return serverArguments;
  }

  public PluginIndex getPluginIndex() {
    return pluginIndex;
  }

  public File getScanFile() {
    return scanFile;
  }

  public boolean shouldPrintNotInfectedMessages() {
    return printNotInfectedMessage;
  }

  public File getScanDirectory() {
    return scanDirectory;
  }

  public boolean shouldRunSecurityManager() {
    return runSecurityManager;
  }

  public boolean shouldUseTransformers() {
    return useTransformers;
  }

  public boolean shouldScanDrives() {
    return scanDrives;
  }

  public boolean shouldDisableAutoUpdate() {
    return disableAutoUpdate;
  }

  public boolean singleScan() {
    return singleScan;
  }

  public boolean shouldScanZippedFiles() {
    return scanZippedFiles;
  }

  public boolean shouldLogSecurityManager() {
    return logSecurityManager;
  }

  public boolean shouldScanLatestSpigotResources() {
    return spigotScanner;
  }

  public String getNotificationType() {
    return notifyType;
  }

}
