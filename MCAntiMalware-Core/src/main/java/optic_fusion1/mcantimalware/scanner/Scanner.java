package optic_fusion1.mcantimalware.scanner;

import java.awt.AWTException;
import java.awt.Image;
import java.awt.SystemTray;
import java.awt.Toolkit;
import java.awt.TrayIcon;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.util.Iterator;
import java.util.List;
import java.util.PriorityQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.ZipFile;
import optic_fusion1.mcantimalware.CommandLineParser;
import optic_fusion1.mcantimalware.Main;
import optic_fusion1.mcantimalware.check.BaseCheck;
import optic_fusion1.mcantimalware.check.CheckManagerImpl;
import optic_fusion1.mcantimalware.configuration.file.FileConfiguration;
import optic_fusion1.mcantimalware.configuration.file.YamlConfiguration;
import optic_fusion1.mcantimalware.logging.CustomLogger;
import optic_fusion1.mcantimalware.utils.FileSizeComparator;
import optic_fusion1.mcantimalware.utils.I18n;
import optic_fusion1.mcantimalware.utils.ZipUtils;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.io.IOUtils;

//TODO: Re-Implement Auto-Updater and RealTimeScanner
public class Scanner extends Thread {

  private final Main main;
  private final CustomLogger logger;
  private final File scanDirectory;
  private File serverJar;
  private String fileInfo = "";
  private boolean firstScan = true;
  private final CheckManagerImpl checkManager;
  private FileConfiguration checksumDatabase;
  private Status status = Status.WAITING;
  //TODO: Fully implement the queueing system
  private PriorityQueue queue = new PriorityQueue();
  private CommandLineParser commandLineParser;

  public enum Status {
    SCANNING,
    WAITING;
  }

  public Scanner(Main main, File scanDirectory) {
    this.main = main;
    this.logger = main.getLogger();
    checkManager = main.getCheckManager();
    commandLineParser = main.getCommandLineParser();
    checksumDatabase = main.getChecksumDatabase();
    this.scanDirectory = scanDirectory;
  }

  @Override
  public void run() {
    //TODO: Re-look into this loop
    while (true) {
      if (firstScan && status == Status.WAITING) {
        status = Status.SCANNING;
        scanFiles();
        status = Status.WAITING;
        firstScan = false;
      }
      if (status == Status.WAITING && !queue.isEmpty()) {
        status = Status.SCANNING;
        //TODO: Could possibly be optimized or done better
        Iterator<File> iterator = queue.iterator();
        while (iterator.hasNext()) {
          scanFile(iterator.next());
          iterator.remove();
        }
        status = Status.WAITING;
      }
      if (status == Status.WAITING && main.getCommandLineParser().singleScan()) {
        try {
          join();
          main.join();
          System.exit(0);
        } catch (InterruptedException ex) {
          logger.exception(ex);
        }
      }
    }
  }

  public void scanFiles() {
    File[] files = scanDirectory.listFiles();
    logger.info(I18n.tl("file_sort_start"));
    FileSizeComparator comparator = new FileSizeComparator();
    comparator.sort(files);
    logger.info(I18n.tl("file_sort_end"));
    logger.info(I18n.tl("scan_start"));
    for (File file : files) {
      if (file.isDirectory()) {
        scanDirectory(file);
        continue;
      }
      scanFile(file);
    }
    logger.info(I18n.tl("scan_end"));
  }

  public void scanDirectory(File directory) {
    if (!directory.isDirectory()) {
      scanFile(directory);
      return;
    }
    for (File file : directory.listFiles()) {
      if (file.isDirectory()) {
        scanDirectory(file);
        continue;
      }
      scanFile(file);
    }
  }

  public void scanFile(File file) {
    if (file.isDirectory()) {
      scanDirectory(file);
      return;
    }
    if (file.length() == 0) {
      return;
    }
    String fileName = file.getName();
    if (!fileName.endsWith(".jar") && !fileName.endsWith(".zip") && !fileName.endsWith(".rar") || fileName.equals("MCAntiMalware.jar")) {
      return;
    }
    String filePath = file.toString();
    if (commandLineParser.shouldScanZippedFiles()) {
      if (fileName.endsWith(".zip") || fileName.endsWith(".rar")) {
        try {
          File tempDir = ZipUtils.unzipFileToTempDir(filePath);
          fileInfo = IOUtils.toString(new FileInputStream(new File(tempDir.getPath(), "file.info")), "UTF-8");
          scanDirectory(tempDir);
          return;
        } catch (FileNotFoundException ex) {
          logger.exception(ex);
        } catch (IOException ex) {
          logger.exception(ex);
        }
      }
    }
    WhitelistResult result = isFileWhitelisted(file);
    if (result == WhitelistResult.INVALID_FILE || result == WhitelistResult.WHITELISTED || result == WhitelistResult.BLACKLISTED_AUTHOR) {
      return;
    }
    ZipFile zipFile = null;
    try {
      zipFile = new ZipFile(file);
      for (BaseCheck check : checkManager.getChecks()) {
        try {
          check.process(filePath, zipFile);
        } catch (Exception e) {
          continue;
        }
        if (!(check.getScore() >= check.getThreshold())) {
          if (commandLineParser.shouldPrintNotInfectedMessages()) {
            logger.info(I18n.tl("might_not_be_infected",
                    (fileInfo != null && fileInfo.isEmpty() ? "" : fileInfo + "#") + fileName,
                    check.getLogName(),
                    check.getType()));
          }
        } else {
          logger.detected(I18n.tl("might_be_infected",
                  (fileInfo != null && fileInfo.isEmpty() ? "" : fileInfo + "#") + fileName,
                  check.getLogName(),
                  check.getType(),
                  check.getClassNodePath(),
                  (check.getLine() > -1 ? check.getLine() : "none"),
                  (!check.getSourceFilePath().isEmpty() ? check.getSourceFilePath() : "none")));
          if (commandLineParser.shouldNotifyWhenMalicious()) {
            showTrayPopup(filePath, check);
          }
        }
        check.reset();
        fileInfo = "";
      }
      zipFile.close();
    } catch (IOException ex) {
      logger.exception(ex);
      if (zipFile != null) {
        try {
          zipFile.close();
        } catch (IOException ex1) {
          Logger.getLogger(Scanner.class.getName()).log(Level.SEVERE, null, ex1);
        }
      }
    }
  }

  public enum WhitelistResult {
    INVALID_FILE,
    NO_PLUGIN_YML,
    INVALID_PLUGIN_YML,
    NOT_WHITELISTED,
    WHITELISTED,
    BLACKLISTED_AUTHOR;
  }

  private WhitelistResult isFileWhitelisted(File file) {
    if (file == null || file.length() == 0) {
      return WhitelistResult.INVALID_FILE;
    }
    if (checksumDatabase == null) {
      return WhitelistResult.NOT_WHITELISTED;
    }
    String fileName = file.getName();
    if (serverJar != null && fileName.equals(serverJar.getName())) {
      return WhitelistResult.NOT_WHITELISTED;
    }
    try {
      JarFile jarFile = new JarFile(file);
      JarEntry entry = jarFile.getJarEntry("plugin.yml");
      if (entry == null) {
        logger.info(I18n.tl("has_no_plugin_yml", fileName));
        jarFile.close();
        return WhitelistResult.NO_PLUGIN_YML;
      }
      InputStream inputStream = jarFile.getInputStream(entry);
      if (inputStream == null) {
        jarFile.close();
        return WhitelistResult.NO_PLUGIN_YML;
      }
      FileConfiguration config = null;
      try {
        config = YamlConfiguration.loadConfiguration(inputStream);
      } catch (Exception e) {
        inputStream.close();
        jarFile.close();
        return WhitelistResult.NOT_WHITELISTED;
      }
      if (!config.isSet("author") && !config.isSet("name")) {
        inputStream.close();
        jarFile.close();
        return WhitelistResult.INVALID_PLUGIN_YML;
      }
      //TODO: Properly support author lists
      String author = config.isSet("author") ? config.getString("author").replaceAll(" ", "-").replaceAll("\\.", "-") : null;
      if (author != null) {
        boolean blacklisted = false;
        for (BaseCheck check : checkManager.getChecks()) {
          for (String blacklistedAuthor : check.getBlacklistedAuthors()) {
            if (author.equals(blacklistedAuthor)) {
              logger.detected(I18n.tl("might_be_infected",
                      (fileInfo != null && fileInfo.isEmpty() ? "" : fileInfo + "#") + fileName,
                      check.getLogName(),
                      check.getType(),
                      check.getClassNodePath(),
                      (check.getLine() > -1 ? check.getLine() : "none"),
                      (!check.getSourceFilePath().isEmpty() ? check.getSourceFilePath() : "none")));
              if (commandLineParser.shouldNotifyWhenMalicious()) {
                showTrayPopup(file.toString(), check);
              }
              blacklisted = true;
            }
          }
        }
        if (blacklisted) {
          inputStream.close();
          jarFile.close();
          return WhitelistResult.BLACKLISTED_AUTHOR;
        }
      }
      String name = config.isSet("name") ? config.getString("name").replaceAll(" ", "-").replaceAll("\\.", "-") : null;
      if (name == null) {
        inputStream.close();
        jarFile.close();
        return WhitelistResult.INVALID_PLUGIN_YML;
      }
      String fileChecksum = DigestUtils.sha1Hex(Files.newInputStream(file.toPath()));
      //TODO: Clean this up, certain chunks of code are duplicated, they can be moved to a separate method
      if (author != null && !author.isEmpty()) {
        if (!checksumDatabase.isSet(author + "." + name)) {
          inputStream.close();
          jarFile.close();
          return WhitelistResult.NOT_WHITELISTED;
        }
        List<String> checksums = checksumDatabase.getStringList(author + "." + name);
        for (String checksum : checksums) {
          if (fileChecksum.equalsIgnoreCase(checksum)) {
            inputStream.close();
            jarFile.close();
            logger.info(I18n.tl("probably_safe", fileName));
            return WhitelistResult.WHITELISTED;
          }
          inputStream.close();
          jarFile.close();
          return WhitelistResult.NOT_WHITELISTED;
        }
        return WhitelistResult.NOT_WHITELISTED;
      }
      if (!checksumDatabase.isSet(name)) {
        inputStream.close();
        jarFile.close();
        return WhitelistResult.NOT_WHITELISTED;
      }
      List<String> checksums = checksumDatabase.getStringList(name);
      for (String checksum : checksums) {
        if (fileChecksum.equalsIgnoreCase(checksum)) {
          logger.info(I18n.tl("probably_safe", file.getName()));
          inputStream.close();
          jarFile.close();
          return WhitelistResult.WHITELISTED;
        }
        inputStream.close();
        jarFile.close();
      }
    } catch (IOException ex) {
      logger.exception(ex);
    }
    return WhitelistResult.NOT_WHITELISTED;
  }

  //TODO: Add linux support for pop-ups, most likely will have to move to native code to achieve that
  private void showTrayPopup(String fullFileName, BaseCheck check) {
    String os = System.getProperty("os.name").toLowerCase();
    if (SystemTray.isSupported() && os.contains("win")) {
      SystemTray tray = SystemTray.getSystemTray();
      Image image = Toolkit.getDefaultToolkit().createImage(Main.class.getResource("/index.jpg"));
      TrayIcon trayIcon = new TrayIcon(image, "Malware Detected");
      trayIcon.setImageAutoSize(true);
      trayIcon.setToolTip(I18n.tl("might_be_infected_tool_tip", fullFileName));
      try {
        tray.add(trayIcon);
        trayIcon.displayMessage(
                I18n.tl("malware_detected_tool_tip_title"),
                I18n.tl("might_be_infected_tool_tip_text",
                        fullFileName,
                        check.getName(),
                        check.getType(),
                        check.getClassNodePath()),
                TrayIcon.MessageType.WARNING);
      } catch (AWTException ex) {
        logger.exception(ex);
      }
      ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
      executor.schedule(() -> tray.remove(trayIcon), 4, TimeUnit.MINUTES);
    }
  }

  public void addFileToQueue(File file) {
    queue.add(file);
  }

  public void reloadChecksumDatabase() {
    logger.info(I18n.tl("updating_local_checksum_database"));
    checksumDatabase = main.getChecksumDatabase();
    logger.info(I18n.tl("updated_local_checksum_database"));
  }

  public File getScanDirectory() {
    return scanDirectory;
  }

  public Status getStatus() {
    return status;
  }

}
