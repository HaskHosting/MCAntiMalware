package optic_fusion1.antimalware.check.impl;

import optic_fusion1.antimalware.check.BaseCheck;
import optic_fusion1.antimalware.check.CacheContainer;
import optic_fusion1.antimalware.check.CheckResult;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import static optic_fusion1.antimalware.AntiMalware.LOGGER;
import static optic_fusion1.antimalware.AntiMalware.getDB;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.LineNumberNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;

public class SystemAccessCheck extends BaseCheck {

  @Override
  public List<CheckResult> process(Path rootFolder, Path zipFile, CacheContainer cache) {
    String[] variant = new String[]{null};
    boolean found = walkThroughFiles(rootFolder).anyMatch((path) -> {
      if (path == null || path.getFileName() == null) {
        return false;
      }
      if (validClassPath(path)) {
        ClassNode classNode = cache.fetchClass(path);
        if (classNode == null) {
          return false;
        }
        List<MethodNode> nodes = classNode.methods;
        for (MethodNode methodNode : nodes) {
          for (AbstractInsnNode insnNode : methodNode.instructions.toArray()) {
            /*
            if (insnNode instanceof LdcInsnNode) {
              String string = ((LdcInsnNode) insnNode).cst.toString();
              if (string.equals("java.lang.Runtime")) {
                MethodInsnNode nextNode = (MethodInsnNode) insnNode.getNext();
                if (nextNode.name.equals("forName") && nextNode.owner.equals("java/lang/Class")
                        && nextNode.desc.equals("(Ljava/lang/String;)Ljava/lang/Class;")) {
                  variant[0] = "Reflection";
                }
              }
            }
            */
            if (insnNode instanceof MethodInsnNode) {
              MethodInsnNode methodInsnNode = (MethodInsnNode) insnNode;
              /*if (methodInsnNode.owner.startsWith("java/lang/Process")
                      || Type.getReturnType(methodInsnNode.desc).getClassName().startsWith("java.lang.Process")) {
                variant[0] = "Process";
              } else*/ if (methodInsnNode.owner.equals("java/lang/Runtime")) {
                if (methodInsnNode.name.equals("exec")) {
                  // TODO: Make this take into account arrays
                  // ATTEMPTED FIX
                  AbstractInsnNode previous = methodInsnNode.getPrevious();
                  if (previous instanceof LdcInsnNode) {
                    variant[0] = "Exec";
                    LdcInsnNode ldc = (LdcInsnNode) previous;
                    LOGGER.info("Checking if exec " + ldc.cst.toString() + " is malicious");
                    if (getDB().isStringBlacklisted(ldc.cst.toString())) {
                      setClassNodePath(classNode.name);
                      setSourceFilePath(classNode.sourceFile);
                      return true;
                    }
                    return false;
                  }
                  return false;
                  // ATTEMPTED FIX
                }
                /*else if (methodInsnNode.name.equals("getRuntime")) {
                  variant[0] = "GetRuntime";
                }*/
              }
              if (variant[0] != null) {
                setClassNodePath(classNode.name);
                setSourceFilePath(classNode.sourceFile);
                return true;
              }
            } else if (insnNode instanceof LineNumberNode) {
              setLine(((LineNumberNode) insnNode).line);
            }
          }
        }
      }
      return false;
    });
    if (found) {
      List<CheckResult> result = new ArrayList<>();
      result.add(new CheckResult("Spigot", "MALWARE", "SystemAccess", variant[0], getSourceFilePath(),
              getClassNodePath(), getLine()));
      return result;
    }
    return new ArrayList<>();
  }

}
